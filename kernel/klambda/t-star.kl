"Copyright (c) 2015, Mark Tarver

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
1. Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.
3. The name of Mark Tarver may not be used to endorse or promote products
   derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY Mark Tarver ''AS IS'' AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL Mark Tarver BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."

(defun shen.typecheck (V3509 V3510) (let Curry (shen.curry V3509) (let ProcessN (shen.start-new-prolog-process) (let Type (shen.insert-prolog-variables (shen.demodulate (shen.curry-type V3510)) ProcessN) (let Continuation (freeze (return Type ProcessN shen.void)) (shen.t* (cons Curry (cons : (cons Type ()))) () ProcessN Continuation))))))

(defun shen.curry (V3512) (cond ((and (cons? V3512) (shen.special? (hd V3512))) (cons (hd V3512) (map (lambda Y (shen.curry Y)) (tl V3512)))) ((and (cons? V3512) (and (cons? (tl V3512)) (shen.extraspecial? (hd V3512)))) V3512) ((and (cons? V3512) (and (= type (hd V3512)) (and (cons? (tl V3512)) (and (cons? (tl (tl V3512))) (= () (tl (tl (tl V3512)))))))) (cons type (cons (shen.curry (hd (tl V3512))) (tl (tl V3512))))) ((and (cons? V3512) (and (cons? (tl V3512)) (cons? (tl (tl V3512))))) (shen.curry (cons (cons (hd V3512) (cons (hd (tl V3512)) ())) (tl (tl V3512))))) ((and (cons? V3512) (and (cons? (tl V3512)) (= () (tl (tl V3512))))) (cons (shen.curry (hd V3512)) (cons (shen.curry (hd (tl V3512))) ()))) (true V3512)))

(defun shen.special? (V3514) (element? V3514 (value shen.*special*)))

(defun shen.extraspecial? (V3516) (element? V3516 (value shen.*extraspecial*)))

(defun shen.t* (V3521 V3522 V3523 V3524) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let Error (shen.newpv V3523) (do (shen.incinfs) (fwhen (shen.maxinfexceeded?) V3523 (freeze (bind Error (shen.errormaxinfs) V3523 V3524))))) (if (= Case false) (let Case (let V3501 (shen.lazyderef V3521 V3523) (if (= fail V3501) (do (shen.incinfs) (cut Throwcontrol V3523 (freeze (shen.prolog-failure V3523 V3524)))) false)) (if (= Case false) (let Case (let V3502 (shen.lazyderef V3521 V3523) (if (cons? V3502) (let X (hd V3502) (let V3503 (shen.lazyderef (tl V3502) V3523) (if (cons? V3503) (let V3504 (shen.lazyderef (hd V3503) V3523) (if (= : V3504) (let V3505 (shen.lazyderef (tl V3503) V3523) (if (cons? V3505) (let A (hd V3505) (let V3506 (shen.lazyderef (tl V3505) V3523) (if (= () V3506) (do (shen.incinfs) (fwhen (shen.type-theory-enabled?) V3523 (freeze (cut Throwcontrol V3523 (freeze (shen.th* X A V3522 V3523 V3524)))))) false))) false)) false)) false))) false)) (if (= Case false) (let Datatypes (shen.newpv V3523) (do (shen.incinfs) (shen.show V3521 V3522 V3523 (freeze (bind Datatypes (value shen.*datatypes*) V3523 (freeze (shen.udefs* V3521 V3522 Datatypes V3523 V3524))))))) Case)) Case)) Case)))))

(defun shen.type-theory-enabled? () (value shen.*shen-type-theory-enabled?*))

(defun enable-type-theory (V3530) (cond ((= + V3530) (set shen.*shen-type-theory-enabled?* true)) ((= - V3530) (set shen.*shen-type-theory-enabled?* false)) (true (simple-error "enable-type-theory expects a + or a -
"))))

(defun shen.prolog-failure (V3541 V3542) false)

(defun shen.maxinfexceeded? () (> (inferences) (value shen.*maxinferences*)))

(defun shen.errormaxinfs () (simple-error "maximum inferences exceeded~%"))

(defun shen.udefs* (V3548 V3549 V3550 V3551 V3552) (let Case (let V3497 (shen.lazyderef V3550 V3551) (if (cons? V3497) (let D (hd V3497) (do (shen.incinfs) (call (cons D (cons V3548 (cons V3549 ()))) V3551 V3552))) false)) (if (= Case false) (let V3498 (shen.lazyderef V3550 V3551) (if (cons? V3498) (let Ds (tl V3498) (do (shen.incinfs) (shen.udefs* V3548 V3549 Ds V3551 V3552))) false)) Case)))

(defun shen.th* (V3558 V3559 V3560 V3561 V3562) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (do (shen.incinfs) (shen.show (cons V3558 (cons : (cons V3559 ()))) V3560 V3561 (freeze (fwhen false V3561 V3562)))) (if (= Case false) (let Case (let F (shen.newpv V3561) (do (shen.incinfs) (fwhen (shen.typedf? (shen.lazyderef V3558 V3561)) V3561 (freeze (bind F (shen.sigf (shen.lazyderef V3558 V3561)) V3561 (freeze (call (cons F (cons V3559 ())) V3561 V3562))))))) (if (= Case false) (let Case (do (shen.incinfs) (shen.base V3558 V3559 V3561 V3562)) (if (= Case false) (let Case (do (shen.incinfs) (shen.by_hypothesis V3558 V3559 V3560 V3561 V3562)) (if (= Case false) (let Case (let V3393 (shen.lazyderef V3558 V3561) (if (cons? V3393) (let F (hd V3393) (let V3394 (shen.lazyderef (tl V3393) V3561) (if (= () V3394) (do (shen.incinfs) (shen.th* F (cons --> (cons V3559 ())) V3560 V3561 V3562)) false))) false)) (if (= Case false) (let Case (let V3395 (shen.lazyderef V3558 V3561) (if (cons? V3395) (let F (hd V3395) (let V3396 (shen.lazyderef (tl V3395) V3561) (if (cons? V3396) (let X (hd V3396) (let V3397 (shen.lazyderef (tl V3396) V3561) (if (= () V3397) (let B (shen.newpv V3561) (do (shen.incinfs) (shen.th* F (cons B (cons --> (cons V3559 ()))) V3560 V3561 (freeze (shen.th* X B V3560 V3561 V3562))))) false))) false))) false)) (if (= Case false) (let Case (let V3398 (shen.lazyderef V3558 V3561) (if (cons? V3398) (let V3399 (shen.lazyderef (hd V3398) V3561) (if (= cons V3399) (let V3400 (shen.lazyderef (tl V3398) V3561) (if (cons? V3400) (let X (hd V3400) (let V3401 (shen.lazyderef (tl V3400) V3561) (if (cons? V3401) (let Y (hd V3401) (let V3402 (shen.lazyderef (tl V3401) V3561) (if (= () V3402) (let V3403 (shen.lazyderef V3559 V3561) (if (cons? V3403) (let V3404 (shen.lazyderef (hd V3403) V3561) (if (= list V3404) (let V3405 (shen.lazyderef (tl V3403) V3561) (if (cons? V3405) (let A (hd V3405) (let V3406 (shen.lazyderef (tl V3405) V3561) (if (= () V3406) (do (shen.incinfs) (shen.th* X A V3560 V3561 (freeze (shen.th* Y (cons list (cons A ())) V3560 V3561 V3562)))) (if (shen.pvar? V3406) (do (shen.bindv V3406 () V3561) (let Result (do (shen.incinfs) (shen.th* X A V3560 V3561 (freeze (shen.th* Y (cons list (cons A ())) V3560 V3561 V3562)))) (do (shen.unbindv V3406 V3561) Result))) false)))) (if (shen.pvar? V3405) (let A (shen.newpv V3561) (do (shen.bindv V3405 (cons A ()) V3561) (let Result (do (shen.incinfs) (shen.th* X A V3560 V3561 (freeze (shen.th* Y (cons list (cons A ())) V3560 V3561 V3562)))) (do (shen.unbindv V3405 V3561) Result)))) false))) (if (shen.pvar? V3404) (do (shen.bindv V3404 list V3561) (let Result (let V3407 (shen.lazyderef (tl V3403) V3561) (if (cons? V3407) (let A (hd V3407) (let V3408 (shen.lazyderef (tl V3407) V3561) (if (= () V3408) (do (shen.incinfs) (shen.th* X A V3560 V3561 (freeze (shen.th* Y (cons list (cons A ())) V3560 V3561 V3562)))) (if (shen.pvar? V3408) (do (shen.bindv V3408 () V3561) (let Result (do (shen.incinfs) (shen.th* X A V3560 V3561 (freeze (shen.th* Y (cons list (cons A ())) V3560 V3561 V3562)))) (do (shen.unbindv V3408 V3561) Result))) false)))) (if (shen.pvar? V3407) (let A (shen.newpv V3561) (do (shen.bindv V3407 (cons A ()) V3561) (let Result (do (shen.incinfs) (shen.th* X A V3560 V3561 (freeze (shen.th* Y (cons list (cons A ())) V3560 V3561 V3562)))) (do (shen.unbindv V3407 V3561) Result)))) false))) (do (shen.unbindv V3404 V3561) Result))) false))) (if (shen.pvar? V3403) (let A (shen.newpv V3561) (do (shen.bindv V3403 (cons list (cons A ())) V3561) (let Result (do (shen.incinfs) (shen.th* X A V3560 V3561 (freeze (shen.th* Y (cons list (cons A ())) V3560 V3561 V3562)))) (do (shen.unbindv V3403 V3561) Result)))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V3409 (shen.lazyderef V3558 V3561) (if (cons? V3409) (let V3410 (shen.lazyderef (hd V3409) V3561) (if (= @p V3410) (let V3411 (shen.lazyderef (tl V3409) V3561) (if (cons? V3411) (let X (hd V3411) (let V3412 (shen.lazyderef (tl V3411) V3561) (if (cons? V3412) (let Y (hd V3412) (let V3413 (shen.lazyderef (tl V3412) V3561) (if (= () V3413) (let V3414 (shen.lazyderef V3559 V3561) (if (cons? V3414) (let A (hd V3414) (let V3415 (shen.lazyderef (tl V3414) V3561) (if (cons? V3415) (let V3416 (shen.lazyderef (hd V3415) V3561) (if (= * V3416) (let V3417 (shen.lazyderef (tl V3415) V3561) (if (cons? V3417) (let B (hd V3417) (let V3418 (shen.lazyderef (tl V3417) V3561) (if (= () V3418) (do (shen.incinfs) (shen.th* X A V3560 V3561 (freeze (shen.th* Y B V3560 V3561 V3562)))) (if (shen.pvar? V3418) (do (shen.bindv V3418 () V3561) (let Result (do (shen.incinfs) (shen.th* X A V3560 V3561 (freeze (shen.th* Y B V3560 V3561 V3562)))) (do (shen.unbindv V3418 V3561) Result))) false)))) (if (shen.pvar? V3417) (let B (shen.newpv V3561) (do (shen.bindv V3417 (cons B ()) V3561) (let Result (do (shen.incinfs) (shen.th* X A V3560 V3561 (freeze (shen.th* Y B V3560 V3561 V3562)))) (do (shen.unbindv V3417 V3561) Result)))) false))) (if (shen.pvar? V3416) (do (shen.bindv V3416 * V3561) (let Result (let V3419 (shen.lazyderef (tl V3415) V3561) (if (cons? V3419) (let B (hd V3419) (let V3420 (shen.lazyderef (tl V3419) V3561) (if (= () V3420) (do (shen.incinfs) (shen.th* X A V3560 V3561 (freeze (shen.th* Y B V3560 V3561 V3562)))) (if (shen.pvar? V3420) (do (shen.bindv V3420 () V3561) (let Result (do (shen.incinfs) (shen.th* X A V3560 V3561 (freeze (shen.th* Y B V3560 V3561 V3562)))) (do (shen.unbindv V3420 V3561) Result))) false)))) (if (shen.pvar? V3419) (let B (shen.newpv V3561) (do (shen.bindv V3419 (cons B ()) V3561) (let Result (do (shen.incinfs) (shen.th* X A V3560 V3561 (freeze (shen.th* Y B V3560 V3561 V3562)))) (do (shen.unbindv V3419 V3561) Result)))) false))) (do (shen.unbindv V3416 V3561) Result))) false))) (if (shen.pvar? V3415) (let B (shen.newpv V3561) (do (shen.bindv V3415 (cons * (cons B ())) V3561) (let Result (do (shen.incinfs) (shen.th* X A V3560 V3561 (freeze (shen.th* Y B V3560 V3561 V3562)))) (do (shen.unbindv V3415 V3561) Result)))) false)))) (if (shen.pvar? V3414) (let A (shen.newpv V3561) (let B (shen.newpv V3561) (do (shen.bindv V3414 (cons A (cons * (cons B ()))) V3561) (let Result (do (shen.incinfs) (shen.th* X A V3560 V3561 (freeze (shen.th* Y B V3560 V3561 V3562)))) (do (shen.unbindv V3414 V3561) Result))))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V3421 (shen.lazyderef V3558 V3561) (if (cons? V3421) (let V3422 (shen.lazyderef (hd V3421) V3561) (if (= @v V3422) (let V3423 (shen.lazyderef (tl V3421) V3561) (if (cons? V3423) (let X (hd V3423) (let V3424 (shen.lazyderef (tl V3423) V3561) (if (cons? V3424) (let Y (hd V3424) (let V3425 (shen.lazyderef (tl V3424) V3561) (if (= () V3425) (let V3426 (shen.lazyderef V3559 V3561) (if (cons? V3426) (let V3427 (shen.lazyderef (hd V3426) V3561) (if (= vector V3427) (let V3428 (shen.lazyderef (tl V3426) V3561) (if (cons? V3428) (let A (hd V3428) (let V3429 (shen.lazyderef (tl V3428) V3561) (if (= () V3429) (do (shen.incinfs) (shen.th* X A V3560 V3561 (freeze (shen.th* Y (cons vector (cons A ())) V3560 V3561 V3562)))) (if (shen.pvar? V3429) (do (shen.bindv V3429 () V3561) (let Result (do (shen.incinfs) (shen.th* X A V3560 V3561 (freeze (shen.th* Y (cons vector (cons A ())) V3560 V3561 V3562)))) (do (shen.unbindv V3429 V3561) Result))) false)))) (if (shen.pvar? V3428) (let A (shen.newpv V3561) (do (shen.bindv V3428 (cons A ()) V3561) (let Result (do (shen.incinfs) (shen.th* X A V3560 V3561 (freeze (shen.th* Y (cons vector (cons A ())) V3560 V3561 V3562)))) (do (shen.unbindv V3428 V3561) Result)))) false))) (if (shen.pvar? V3427) (do (shen.bindv V3427 vector V3561) (let Result (let V3430 (shen.lazyderef (tl V3426) V3561) (if (cons? V3430) (let A (hd V3430) (let V3431 (shen.lazyderef (tl V3430) V3561) (if (= () V3431) (do (shen.incinfs) (shen.th* X A V3560 V3561 (freeze (shen.th* Y (cons vector (cons A ())) V3560 V3561 V3562)))) (if (shen.pvar? V3431) (do (shen.bindv V3431 () V3561) (let Result (do (shen.incinfs) (shen.th* X A V3560 V3561 (freeze (shen.th* Y (cons vector (cons A ())) V3560 V3561 V3562)))) (do (shen.unbindv V3431 V3561) Result))) false)))) (if (shen.pvar? V3430) (let A (shen.newpv V3561) (do (shen.bindv V3430 (cons A ()) V3561) (let Result (do (shen.incinfs) (shen.th* X A V3560 V3561 (freeze (shen.th* Y (cons vector (cons A ())) V3560 V3561 V3562)))) (do (shen.unbindv V3430 V3561) Result)))) false))) (do (shen.unbindv V3427 V3561) Result))) false))) (if (shen.pvar? V3426) (let A (shen.newpv V3561) (do (shen.bindv V3426 (cons vector (cons A ())) V3561) (let Result (do (shen.incinfs) (shen.th* X A V3560 V3561 (freeze (shen.th* Y (cons vector (cons A ())) V3560 V3561 V3562)))) (do (shen.unbindv V3426 V3561) Result)))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V3432 (shen.lazyderef V3558 V3561) (if (cons? V3432) (let V3433 (shen.lazyderef (hd V3432) V3561) (if (= @s V3433) (let V3434 (shen.lazyderef (tl V3432) V3561) (if (cons? V3434) (let X (hd V3434) (let V3435 (shen.lazyderef (tl V3434) V3561) (if (cons? V3435) (let Y (hd V3435) (let V3436 (shen.lazyderef (tl V3435) V3561) (if (= () V3436) (let V3437 (shen.lazyderef V3559 V3561) (if (= string V3437) (do (shen.incinfs) (shen.th* X string V3560 V3561 (freeze (shen.th* Y string V3560 V3561 V3562)))) (if (shen.pvar? V3437) (do (shen.bindv V3437 string V3561) (let Result (do (shen.incinfs) (shen.th* X string V3560 V3561 (freeze (shen.th* Y string V3560 V3561 V3562)))) (do (shen.unbindv V3437 V3561) Result))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V3438 (shen.lazyderef V3558 V3561) (if (cons? V3438) (let V3439 (shen.lazyderef (hd V3438) V3561) (if (= lambda V3439) (let V3440 (shen.lazyderef (tl V3438) V3561) (if (cons? V3440) (let X (hd V3440) (let V3441 (shen.lazyderef (tl V3440) V3561) (if (cons? V3441) (let Y (hd V3441) (let V3442 (shen.lazyderef (tl V3441) V3561) (if (= () V3442) (let V3443 (shen.lazyderef V3559 V3561) (if (cons? V3443) (let A (hd V3443) (let V3444 (shen.lazyderef (tl V3443) V3561) (if (cons? V3444) (let V3445 (shen.lazyderef (hd V3444) V3561) (if (= --> V3445) (let V3446 (shen.lazyderef (tl V3444) V3561) (if (cons? V3446) (let B (hd V3446) (let V3447 (shen.lazyderef (tl V3446) V3561) (if (= () V3447) (let Z (shen.newpv V3561) (let X&& (shen.newpv V3561) (do (shen.incinfs) (cut Throwcontrol V3561 (freeze (bind X&& (shen.placeholder) V3561 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V3561) (shen.lazyderef X V3561) (shen.lazyderef Y V3561)) V3561 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V3560) V3561 V3562)))))))))) (if (shen.pvar? V3447) (do (shen.bindv V3447 () V3561) (let Result (let Z (shen.newpv V3561) (let X&& (shen.newpv V3561) (do (shen.incinfs) (cut Throwcontrol V3561 (freeze (bind X&& (shen.placeholder) V3561 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V3561) (shen.lazyderef X V3561) (shen.lazyderef Y V3561)) V3561 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V3560) V3561 V3562)))))))))) (do (shen.unbindv V3447 V3561) Result))) false)))) (if (shen.pvar? V3446) (let B (shen.newpv V3561) (do (shen.bindv V3446 (cons B ()) V3561) (let Result (let Z (shen.newpv V3561) (let X&& (shen.newpv V3561) (do (shen.incinfs) (cut Throwcontrol V3561 (freeze (bind X&& (shen.placeholder) V3561 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V3561) (shen.lazyderef X V3561) (shen.lazyderef Y V3561)) V3561 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V3560) V3561 V3562)))))))))) (do (shen.unbindv V3446 V3561) Result)))) false))) (if (shen.pvar? V3445) (do (shen.bindv V3445 --> V3561) (let Result (let V3448 (shen.lazyderef (tl V3444) V3561) (if (cons? V3448) (let B (hd V3448) (let V3449 (shen.lazyderef (tl V3448) V3561) (if (= () V3449) (let Z (shen.newpv V3561) (let X&& (shen.newpv V3561) (do (shen.incinfs) (cut Throwcontrol V3561 (freeze (bind X&& (shen.placeholder) V3561 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V3561) (shen.lazyderef X V3561) (shen.lazyderef Y V3561)) V3561 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V3560) V3561 V3562)))))))))) (if (shen.pvar? V3449) (do (shen.bindv V3449 () V3561) (let Result (let Z (shen.newpv V3561) (let X&& (shen.newpv V3561) (do (shen.incinfs) (cut Throwcontrol V3561 (freeze (bind X&& (shen.placeholder) V3561 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V3561) (shen.lazyderef X V3561) (shen.lazyderef Y V3561)) V3561 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V3560) V3561 V3562)))))))))) (do (shen.unbindv V3449 V3561) Result))) false)))) (if (shen.pvar? V3448) (let B (shen.newpv V3561) (do (shen.bindv V3448 (cons B ()) V3561) (let Result (let Z (shen.newpv V3561) (let X&& (shen.newpv V3561) (do (shen.incinfs) (cut Throwcontrol V3561 (freeze (bind X&& (shen.placeholder) V3561 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V3561) (shen.lazyderef X V3561) (shen.lazyderef Y V3561)) V3561 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V3560) V3561 V3562)))))))))) (do (shen.unbindv V3448 V3561) Result)))) false))) (do (shen.unbindv V3445 V3561) Result))) false))) (if (shen.pvar? V3444) (let B (shen.newpv V3561) (do (shen.bindv V3444 (cons --> (cons B ())) V3561) (let Result (let Z (shen.newpv V3561) (let X&& (shen.newpv V3561) (do (shen.incinfs) (cut Throwcontrol V3561 (freeze (bind X&& (shen.placeholder) V3561 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V3561) (shen.lazyderef X V3561) (shen.lazyderef Y V3561)) V3561 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V3560) V3561 V3562)))))))))) (do (shen.unbindv V3444 V3561) Result)))) false)))) (if (shen.pvar? V3443) (let A (shen.newpv V3561) (let B (shen.newpv V3561) (do (shen.bindv V3443 (cons A (cons --> (cons B ()))) V3561) (let Result (let Z (shen.newpv V3561) (let X&& (shen.newpv V3561) (do (shen.incinfs) (cut Throwcontrol V3561 (freeze (bind X&& (shen.placeholder) V3561 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V3561) (shen.lazyderef X V3561) (shen.lazyderef Y V3561)) V3561 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V3560) V3561 V3562)))))))))) (do (shen.unbindv V3443 V3561) Result))))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V3450 (shen.lazyderef V3558 V3561) (if (cons? V3450) (let V3451 (shen.lazyderef (hd V3450) V3561) (if (= let V3451) (let V3452 (shen.lazyderef (tl V3450) V3561) (if (cons? V3452) (let X (hd V3452) (let V3453 (shen.lazyderef (tl V3452) V3561) (if (cons? V3453) (let Y (hd V3453) (let V3454 (shen.lazyderef (tl V3453) V3561) (if (cons? V3454) (let Z (hd V3454) (let V3455 (shen.lazyderef (tl V3454) V3561) (if (= () V3455) (let W (shen.newpv V3561) (let X&& (shen.newpv V3561) (let B (shen.newpv V3561) (do (shen.incinfs) (shen.th* Y B V3560 V3561 (freeze (bind X&& (shen.placeholder) V3561 (freeze (bind W (shen.ebr (shen.lazyderef X&& V3561) (shen.lazyderef X V3561) (shen.lazyderef Z V3561)) V3561 (freeze (shen.th* W V3559 (cons (cons X&& (cons : (cons B ()))) V3560) V3561 V3562))))))))))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V3456 (shen.lazyderef V3558 V3561) (if (cons? V3456) (let V3457 (shen.lazyderef (hd V3456) V3561) (if (= open V3457) (let V3458 (shen.lazyderef (tl V3456) V3561) (if (cons? V3458) (let FileName (hd V3458) (let V3459 (shen.lazyderef (tl V3458) V3561) (if (cons? V3459) (let Direction3389 (hd V3459) (let V3460 (shen.lazyderef (tl V3459) V3561) (if (= () V3460) (let V3461 (shen.lazyderef V3559 V3561) (if (cons? V3461) (let V3462 (shen.lazyderef (hd V3461) V3561) (if (= stream V3462) (let V3463 (shen.lazyderef (tl V3461) V3561) (if (cons? V3463) (let Direction (hd V3463) (let V3464 (shen.lazyderef (tl V3463) V3561) (if (= () V3464) (do (shen.incinfs) (unify! Direction Direction3389 V3561 (freeze (cut Throwcontrol V3561 (freeze (fwhen (element? (shen.lazyderef Direction V3561) (cons in (cons out ()))) V3561 (freeze (shen.th* FileName string V3560 V3561 V3562)))))))) (if (shen.pvar? V3464) (do (shen.bindv V3464 () V3561) (let Result (do (shen.incinfs) (unify! Direction Direction3389 V3561 (freeze (cut Throwcontrol V3561 (freeze (fwhen (element? (shen.lazyderef Direction V3561) (cons in (cons out ()))) V3561 (freeze (shen.th* FileName string V3560 V3561 V3562)))))))) (do (shen.unbindv V3464 V3561) Result))) false)))) (if (shen.pvar? V3463) (let Direction (shen.newpv V3561) (do (shen.bindv V3463 (cons Direction ()) V3561) (let Result (do (shen.incinfs) (unify! Direction Direction3389 V3561 (freeze (cut Throwcontrol V3561 (freeze (fwhen (element? (shen.lazyderef Direction V3561) (cons in (cons out ()))) V3561 (freeze (shen.th* FileName string V3560 V3561 V3562)))))))) (do (shen.unbindv V3463 V3561) Result)))) false))) (if (shen.pvar? V3462) (do (shen.bindv V3462 stream V3561) (let Result (let V3465 (shen.lazyderef (tl V3461) V3561) (if (cons? V3465) (let Direction (hd V3465) (let V3466 (shen.lazyderef (tl V3465) V3561) (if (= () V3466) (do (shen.incinfs) (unify! Direction Direction3389 V3561 (freeze (cut Throwcontrol V3561 (freeze (fwhen (element? (shen.lazyderef Direction V3561) (cons in (cons out ()))) V3561 (freeze (shen.th* FileName string V3560 V3561 V3562)))))))) (if (shen.pvar? V3466) (do (shen.bindv V3466 () V3561) (let Result (do (shen.incinfs) (unify! Direction Direction3389 V3561 (freeze (cut Throwcontrol V3561 (freeze (fwhen (element? (shen.lazyderef Direction V3561) (cons in (cons out ()))) V3561 (freeze (shen.th* FileName string V3560 V3561 V3562)))))))) (do (shen.unbindv V3466 V3561) Result))) false)))) (if (shen.pvar? V3465) (let Direction (shen.newpv V3561) (do (shen.bindv V3465 (cons Direction ()) V3561) (let Result (do (shen.incinfs) (unify! Direction Direction3389 V3561 (freeze (cut Throwcontrol V3561 (freeze (fwhen (element? (shen.lazyderef Direction V3561) (cons in (cons out ()))) V3561 (freeze (shen.th* FileName string V3560 V3561 V3562)))))))) (do (shen.unbindv V3465 V3561) Result)))) false))) (do (shen.unbindv V3462 V3561) Result))) false))) (if (shen.pvar? V3461) (let Direction (shen.newpv V3561) (do (shen.bindv V3461 (cons stream (cons Direction ())) V3561) (let Result (do (shen.incinfs) (unify! Direction Direction3389 V3561 (freeze (cut Throwcontrol V3561 (freeze (fwhen (element? (shen.lazyderef Direction V3561) (cons in (cons out ()))) V3561 (freeze (shen.th* FileName string V3560 V3561 V3562)))))))) (do (shen.unbindv V3461 V3561) Result)))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V3467 (shen.lazyderef V3558 V3561) (if (cons? V3467) (let V3468 (shen.lazyderef (hd V3467) V3561) (if (= type V3468) (let V3469 (shen.lazyderef (tl V3467) V3561) (if (cons? V3469) (let X (hd V3469) (let V3470 (shen.lazyderef (tl V3469) V3561) (if (cons? V3470) (let A (hd V3470) (let V3471 (shen.lazyderef (tl V3470) V3561) (if (= () V3471) (do (shen.incinfs) (cut Throwcontrol V3561 (freeze (unify A V3559 V3561 (freeze (shen.th* X A V3560 V3561 V3562)))))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V3472 (shen.lazyderef V3558 V3561) (if (cons? V3472) (let V3473 (shen.lazyderef (hd V3472) V3561) (if (= input+ V3473) (let V3474 (shen.lazyderef (tl V3472) V3561) (if (cons? V3474) (let A (hd V3474) (let V3475 (shen.lazyderef (tl V3474) V3561) (if (cons? V3475) (let Stream (hd V3475) (let V3476 (shen.lazyderef (tl V3475) V3561) (if (= () V3476) (let C (shen.newpv V3561) (do (shen.incinfs) (bind C (shen.demodulate (shen.lazyderef A V3561)) V3561 (freeze (unify V3559 C V3561 (freeze (shen.th* Stream (cons stream (cons in ())) V3560 V3561 V3562))))))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V3477 (shen.lazyderef V3558 V3561) (if (cons? V3477) (let V3478 (shen.lazyderef (hd V3477) V3561) (if (= set V3478) (let V3479 (shen.lazyderef (tl V3477) V3561) (if (cons? V3479) (let Var (hd V3479) (let V3480 (shen.lazyderef (tl V3479) V3561) (if (cons? V3480) (let Val (hd V3480) (let V3481 (shen.lazyderef (tl V3480) V3561) (if (= () V3481) (do (shen.incinfs) (cut Throwcontrol V3561 (freeze (shen.th* Var symbol V3560 V3561 (freeze (cut Throwcontrol V3561 (freeze (shen.th* (cons value (cons Var ())) V3559 V3560 V3561 (freeze (shen.th* Val V3559 V3560 V3561 V3562)))))))))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let NewHyp (shen.newpv V3561) (do (shen.incinfs) (shen.t*-hyps V3560 NewHyp V3561 (freeze (shen.th* V3558 V3559 NewHyp V3561 V3562))))) (if (= Case false) (let Case (let V3482 (shen.lazyderef V3558 V3561) (if (cons? V3482) (let V3483 (shen.lazyderef (hd V3482) V3561) (if (= define V3483) (let V3484 (shen.lazyderef (tl V3482) V3561) (if (cons? V3484) (let F (hd V3484) (let X (tl V3484) (do (shen.incinfs) (cut Throwcontrol V3561 (freeze (shen.t*-def (cons define (cons F X)) V3559 V3560 V3561 V3562)))))) false)) false)) false)) (if (= Case false) (let Case (let V3485 (shen.lazyderef V3558 V3561) (if (cons? V3485) (let V3486 (shen.lazyderef (hd V3485) V3561) (if (= defmacro V3486) (let V3487 (shen.lazyderef V3559 V3561) (if (= unit V3487) (do (shen.incinfs) (cut Throwcontrol V3561 V3562)) (if (shen.pvar? V3487) (do (shen.bindv V3487 unit V3561) (let Result (do (shen.incinfs) (cut Throwcontrol V3561 V3562)) (do (shen.unbindv V3487 V3561) Result))) false))) false)) false)) (if (= Case false) (let Case (let V3488 (shen.lazyderef V3558 V3561) (if (cons? V3488) (let V3489 (shen.lazyderef (hd V3488) V3561) (if (= shen.process-datatype V3489) (let V3490 (shen.lazyderef V3559 V3561) (if (= symbol V3490) (do (shen.incinfs) (thaw V3562)) (if (shen.pvar? V3490) (do (shen.bindv V3490 symbol V3561) (let Result (do (shen.incinfs) (thaw V3562)) (do (shen.unbindv V3490 V3561) Result))) false))) false)) false)) (if (= Case false) (let Case (let V3491 (shen.lazyderef V3558 V3561) (if (cons? V3491) (let V3492 (shen.lazyderef (hd V3491) V3561) (if (= shen.synonyms-help V3492) (let V3493 (shen.lazyderef V3559 V3561) (if (= symbol V3493) (do (shen.incinfs) (thaw V3562)) (if (shen.pvar? V3493) (do (shen.bindv V3493 symbol V3561) (let Result (do (shen.incinfs) (thaw V3562)) (do (shen.unbindv V3493 V3561) Result))) false))) false)) false)) (if (= Case false) (let Datatypes (shen.newpv V3561) (do (shen.incinfs) (bind Datatypes (value shen.*datatypes*) V3561 (freeze (shen.udefs* (cons V3558 (cons : (cons V3559 ()))) V3560 Datatypes V3561 V3562))))) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)))))

(defun shen.t*-hyps (V3567 V3568 V3569 V3570) (let Case (let V3304 (shen.lazyderef V3567 V3569) (if (cons? V3304) (let V3305 (shen.lazyderef (hd V3304) V3569) (if (cons? V3305) (let V3306 (shen.lazyderef (hd V3305) V3569) (if (cons? V3306) (let V3307 (shen.lazyderef (hd V3306) V3569) (if (= cons V3307) (let V3308 (shen.lazyderef (tl V3306) V3569) (if (cons? V3308) (let X (hd V3308) (let V3309 (shen.lazyderef (tl V3308) V3569) (if (cons? V3309) (let Y (hd V3309) (let V3310 (shen.lazyderef (tl V3309) V3569) (if (= () V3310) (let V3311 (shen.lazyderef (tl V3305) V3569) (if (cons? V3311) (let V3312 (shen.lazyderef (hd V3311) V3569) (if (= : V3312) (let V3313 (shen.lazyderef (tl V3311) V3569) (if (cons? V3313) (let V3314 (shen.lazyderef (hd V3313) V3569) (if (cons? V3314) (let V3315 (shen.lazyderef (hd V3314) V3569) (if (= list V3315) (let V3316 (shen.lazyderef (tl V3314) V3569) (if (cons? V3316) (let A (hd V3316) (let V3317 (shen.lazyderef (tl V3316) V3569) (if (= () V3317) (let V3318 (shen.lazyderef (tl V3313) V3569) (if (= () V3318) (let Hyp (tl V3304) (do (shen.incinfs) (bind V3568 (cons (cons (shen.lazyderef X V3569) (cons : (cons (shen.lazyderef A V3569) ()))) (cons (cons (shen.lazyderef Y V3569) (cons : (cons (cons list (cons (shen.lazyderef A V3569) ())) ()))) (shen.lazyderef Hyp V3569))) V3569 V3570))) (if (shen.pvar? V3318) (do (shen.bindv V3318 () V3569) (let Result (let Hyp (tl V3304) (do (shen.incinfs) (bind V3568 (cons (cons (shen.lazyderef X V3569) (cons : (cons (shen.lazyderef A V3569) ()))) (cons (cons (shen.lazyderef Y V3569) (cons : (cons (cons list (cons (shen.lazyderef A V3569) ())) ()))) (shen.lazyderef Hyp V3569))) V3569 V3570))) (do (shen.unbindv V3318 V3569) Result))) false))) (if (shen.pvar? V3317) (do (shen.bindv V3317 () V3569) (let Result (let V3319 (shen.lazyderef (tl V3313) V3569) (if (= () V3319) (let Hyp (tl V3304) (do (shen.incinfs) (bind V3568 (cons (cons (shen.lazyderef X V3569) (cons : (cons (shen.lazyderef A V3569) ()))) (cons (cons (shen.lazyderef Y V3569) (cons : (cons (cons list (cons (shen.lazyderef A V3569) ())) ()))) (shen.lazyderef Hyp V3569))) V3569 V3570))) (if (shen.pvar? V3319) (do (shen.bindv V3319 () V3569) (let Result (let Hyp (tl V3304) (do (shen.incinfs) (bind V3568 (cons (cons (shen.lazyderef X V3569) (cons : (cons (shen.lazyderef A V3569) ()))) (cons (cons (shen.lazyderef Y V3569) (cons : (cons (cons list (cons (shen.lazyderef A V3569) ())) ()))) (shen.lazyderef Hyp V3569))) V3569 V3570))) (do (shen.unbindv V3319 V3569) Result))) false))) (do (shen.unbindv V3317 V3569) Result))) false)))) (if (shen.pvar? V3316) (let A (shen.newpv V3569) (do (shen.bindv V3316 (cons A ()) V3569) (let Result (let V3320 (shen.lazyderef (tl V3313) V3569) (if (= () V3320) (let Hyp (tl V3304) (do (shen.incinfs) (bind V3568 (cons (cons (shen.lazyderef X V3569) (cons : (cons (shen.lazyderef A V3569) ()))) (cons (cons (shen.lazyderef Y V3569) (cons : (cons (cons list (cons (shen.lazyderef A V3569) ())) ()))) (shen.lazyderef Hyp V3569))) V3569 V3570))) (if (shen.pvar? V3320) (do (shen.bindv V3320 () V3569) (let Result (let Hyp (tl V3304) (do (shen.incinfs) (bind V3568 (cons (cons (shen.lazyderef X V3569) (cons : (cons (shen.lazyderef A V3569) ()))) (cons (cons (shen.lazyderef Y V3569) (cons : (cons (cons list (cons (shen.lazyderef A V3569) ())) ()))) (shen.lazyderef Hyp V3569))) V3569 V3570))) (do (shen.unbindv V3320 V3569) Result))) false))) (do (shen.unbindv V3316 V3569) Result)))) false))) (if (shen.pvar? V3315) (do (shen.bindv V3315 list V3569) (let Result (let V3321 (shen.lazyderef (tl V3314) V3569) (if (cons? V3321) (let A (hd V3321) (let V3322 (shen.lazyderef (tl V3321) V3569) (if (= () V3322) (let V3323 (shen.lazyderef (tl V3313) V3569) (if (= () V3323) (let Hyp (tl V3304) (do (shen.incinfs) (bind V3568 (cons (cons (shen.lazyderef X V3569) (cons : (cons (shen.lazyderef A V3569) ()))) (cons (cons (shen.lazyderef Y V3569) (cons : (cons (cons list (cons (shen.lazyderef A V3569) ())) ()))) (shen.lazyderef Hyp V3569))) V3569 V3570))) (if (shen.pvar? V3323) (do (shen.bindv V3323 () V3569) (let Result (let Hyp (tl V3304) (do (shen.incinfs) (bind V3568 (cons (cons (shen.lazyderef X V3569) (cons : (cons (shen.lazyderef A V3569) ()))) (cons (cons (shen.lazyderef Y V3569) (cons : (cons (cons list (cons (shen.lazyderef A V3569) ())) ()))) (shen.lazyderef Hyp V3569))) V3569 V3570))) (do (shen.unbindv V3323 V3569) Result))) false))) (if (shen.pvar? V3322) (do (shen.bindv V3322 () V3569) (let Result (let V3324 (shen.lazyderef (tl V3313) V3569) (if (= () V3324) (let Hyp (tl V3304) (do (shen.incinfs) (bind V3568 (cons (cons (shen.lazyderef X V3569) (cons : (cons (shen.lazyderef A V3569) ()))) (cons (cons (shen.lazyderef Y V3569) (cons : (cons (cons list (cons (shen.lazyderef A V3569) ())) ()))) (shen.lazyderef Hyp V3569))) V3569 V3570))) (if (shen.pvar? V3324) (do (shen.bindv V3324 () V3569) (let Result (let Hyp (tl V3304) (do (shen.incinfs) (bind V3568 (cons (cons (shen.lazyderef X V3569) (cons : (cons (shen.lazyderef A V3569) ()))) (cons (cons (shen.lazyderef Y V3569) (cons : (cons (cons list (cons (shen.lazyderef A V3569) ())) ()))) (shen.lazyderef Hyp V3569))) V3569 V3570))) (do (shen.unbindv V3324 V3569) Result))) false))) (do (shen.unbindv V3322 V3569) Result))) false)))) (if (shen.pvar? V3321) (let A (shen.newpv V3569) (do (shen.bindv V3321 (cons A ()) V3569) (let Result (let V3325 (shen.lazyderef (tl V3313) V3569) (if (= () V3325) (let Hyp (tl V3304) (do (shen.incinfs) (bind V3568 (cons (cons (shen.lazyderef X V3569) (cons : (cons (shen.lazyderef A V3569) ()))) (cons (cons (shen.lazyderef Y V3569) (cons : (cons (cons list (cons (shen.lazyderef A V3569) ())) ()))) (shen.lazyderef Hyp V3569))) V3569 V3570))) (if (shen.pvar? V3325) (do (shen.bindv V3325 () V3569) (let Result (let Hyp (tl V3304) (do (shen.incinfs) (bind V3568 (cons (cons (shen.lazyderef X V3569) (cons : (cons (shen.lazyderef A V3569) ()))) (cons (cons (shen.lazyderef Y V3569) (cons : (cons (cons list (cons (shen.lazyderef A V3569) ())) ()))) (shen.lazyderef Hyp V3569))) V3569 V3570))) (do (shen.unbindv V3325 V3569) Result))) false))) (do (shen.unbindv V3321 V3569) Result)))) false))) (do (shen.unbindv V3315 V3569) Result))) false))) (if (shen.pvar? V3314) (let A (shen.newpv V3569) (do (shen.bindv V3314 (cons list (cons A ())) V3569) (let Result (let V3326 (shen.lazyderef (tl V3313) V3569) (if (= () V3326) (let Hyp (tl V3304) (do (shen.incinfs) (bind V3568 (cons (cons (shen.lazyderef X V3569) (cons : (cons (shen.lazyderef A V3569) ()))) (cons (cons (shen.lazyderef Y V3569) (cons : (cons (cons list (cons (shen.lazyderef A V3569) ())) ()))) (shen.lazyderef Hyp V3569))) V3569 V3570))) (if (shen.pvar? V3326) (do (shen.bindv V3326 () V3569) (let Result (let Hyp (tl V3304) (do (shen.incinfs) (bind V3568 (cons (cons (shen.lazyderef X V3569) (cons : (cons (shen.lazyderef A V3569) ()))) (cons (cons (shen.lazyderef Y V3569) (cons : (cons (cons list (cons (shen.lazyderef A V3569) ())) ()))) (shen.lazyderef Hyp V3569))) V3569 V3570))) (do (shen.unbindv V3326 V3569) Result))) false))) (do (shen.unbindv V3314 V3569) Result)))) false))) false)) false)) false)) false))) false))) false)) false)) false)) false)) false)) (if (= Case false) (let Case (let V3327 (shen.lazyderef V3567 V3569) (if (cons? V3327) (let V3328 (shen.lazyderef (hd V3327) V3569) (if (cons? V3328) (let V3329 (shen.lazyderef (hd V3328) V3569) (if (cons? V3329) (let V3330 (shen.lazyderef (hd V3329) V3569) (if (= @p V3330) (let V3331 (shen.lazyderef (tl V3329) V3569) (if (cons? V3331) (let X (hd V3331) (let V3332 (shen.lazyderef (tl V3331) V3569) (if (cons? V3332) (let Y (hd V3332) (let V3333 (shen.lazyderef (tl V3332) V3569) (if (= () V3333) (let V3334 (shen.lazyderef (tl V3328) V3569) (if (cons? V3334) (let V3335 (shen.lazyderef (hd V3334) V3569) (if (= : V3335) (let V3336 (shen.lazyderef (tl V3334) V3569) (if (cons? V3336) (let V3337 (shen.lazyderef (hd V3336) V3569) (if (cons? V3337) (let A (hd V3337) (let V3338 (shen.lazyderef (tl V3337) V3569) (if (cons? V3338) (let V3339 (shen.lazyderef (hd V3338) V3569) (if (= * V3339) (let V3340 (shen.lazyderef (tl V3338) V3569) (if (cons? V3340) (let B (hd V3340) (let V3341 (shen.lazyderef (tl V3340) V3569) (if (= () V3341) (let V3342 (shen.lazyderef (tl V3336) V3569) (if (= () V3342) (let Hyp (tl V3327) (do (shen.incinfs) (bind V3568 (cons (cons (shen.lazyderef X V3569) (cons : (cons (shen.lazyderef A V3569) ()))) (cons (cons (shen.lazyderef Y V3569) (cons : (cons (shen.lazyderef B V3569) ()))) (shen.lazyderef Hyp V3569))) V3569 V3570))) (if (shen.pvar? V3342) (do (shen.bindv V3342 () V3569) (let Result (let Hyp (tl V3327) (do (shen.incinfs) (bind V3568 (cons (cons (shen.lazyderef X V3569) (cons : (cons (shen.lazyderef A V3569) ()))) (cons (cons (shen.lazyderef Y V3569) (cons : (cons (shen.lazyderef B V3569) ()))) (shen.lazyderef Hyp V3569))) V3569 V3570))) (do (shen.unbindv V3342 V3569) Result))) false))) (if (shen.pvar? V3341) (do (shen.bindv V3341 () V3569) (let Result (let V3343 (shen.lazyderef (tl V3336) V3569) (if (= () V3343) (let Hyp (tl V3327) (do (shen.incinfs) (bind V3568 (cons (cons (shen.lazyderef X V3569) (cons : (cons (shen.lazyderef A V3569) ()))) (cons (cons (shen.lazyderef Y V3569) (cons : (cons (shen.lazyderef B V3569) ()))) (shen.lazyderef Hyp V3569))) V3569 V3570))) (if (shen.pvar? V3343) (do (shen.bindv V3343 () V3569) (let Result (let Hyp (tl V3327) (do (shen.incinfs) (bind V3568 (cons (cons (shen.lazyderef X V3569) (cons : (cons (shen.lazyderef A V3569) ()))) (cons (cons (shen.lazyderef Y V3569) (cons : (cons (shen.lazyderef B V3569) ()))) (shen.lazyderef Hyp V3569))) V3569 V3570))) (do (shen.unbindv V3343 V3569) Result))) false))) (do (shen.unbindv V3341 V3569) Result))) false)))) (if (shen.pvar? V3340) (let B (shen.newpv V3569) (do (shen.bindv V3340 (cons B ()) V3569) (let Result (let V3344 (shen.lazyderef (tl V3336) V3569) (if (= () V3344) (let Hyp (tl V3327) (do (shen.incinfs) (bind V3568 (cons (cons (shen.lazyderef X V3569) (cons : (cons (shen.lazyderef A V3569) ()))) (cons (cons (shen.lazyderef Y V3569) (cons : (cons (shen.lazyderef B V3569) ()))) (shen.lazyderef Hyp V3569))) V3569 V3570))) (if (shen.pvar? V3344) (do (shen.bindv V3344 () V3569) (let Result (let Hyp (tl V3327) (do (shen.incinfs) (bind V3568 (cons (cons (shen.lazyderef X V3569) (cons : (cons (shen.lazyderef A V3569) ()))) (cons (cons (shen.lazyderef Y V3569) (cons : (cons (shen.lazyderef B V3569) ()))) (shen.lazyderef Hyp V3569))) V3569 V3570))) (do (shen.unbindv V3344 V3569) Result))) false))) (do (shen.unbindv V3340 V3569) Result)))) false))) (if (shen.pvar? V3339) (do (shen.bindv V3339 * V3569) (let Result (let V3345 (shen.lazyderef (tl V3338) V3569) (if (cons? V3345) (let B (hd V3345) (let V3346 (shen.lazyderef (tl V3345) V3569) (if (= () V3346) (let V3347 (shen.lazyderef (tl V3336) V3569) (if (= () V3347) (let Hyp (tl V3327) (do (shen.incinfs) (bind V3568 (cons (cons (shen.lazyderef X V3569) (cons : (cons (shen.lazyderef A V3569) ()))) (cons (cons (shen.lazyderef Y V3569) (cons : (cons (shen.lazyderef B V3569) ()))) (shen.lazyderef Hyp V3569))) V3569 V3570))) (if (shen.pvar? V3347) (do (shen.bindv V3347 () V3569) (let Result (let Hyp (tl V3327) (do (shen.incinfs) (bind V3568 (cons (cons (shen.lazyderef X V3569) (cons : (cons (shen.lazyderef A V3569) ()))) (cons (cons (shen.lazyderef Y V3569) (cons : (cons (shen.lazyderef B V3569) ()))) (shen.lazyderef Hyp V3569))) V3569 V3570))) (do (shen.unbindv V3347 V3569) Result))) false))) (if (shen.pvar? V3346) (do (shen.bindv V3346 () V3569) (let Result (let V3348 (shen.lazyderef (tl V3336) V3569) (if (= () V3348) (let Hyp (tl V3327) (do (shen.incinfs) (bind V3568 (cons (cons (shen.lazyderef X V3569) (cons : (cons (shen.lazyderef A V3569) ()))) (cons (cons (shen.lazyderef Y V3569) (cons : (cons (shen.lazyderef B V3569) ()))) (shen.lazyderef Hyp V3569))) V3569 V3570))) (if (shen.pvar? V3348) (do (shen.bindv V3348 () V3569) (let Result (let Hyp (tl V3327) (do (shen.incinfs) (bind V3568 (cons (cons (shen.lazyderef X V3569) (cons : (cons (shen.lazyderef A V3569) ()))) (cons (cons (shen.lazyderef Y V3569) (cons : (cons (shen.lazyderef B V3569) ()))) (shen.lazyderef Hyp V3569))) V3569 V3570))) (do (shen.unbindv V3348 V3569) Result))) false))) (do (shen.unbindv V3346 V3569) Result))) false)))) (if (shen.pvar? V3345) (let B (shen.newpv V3569) (do (shen.bindv V3345 (cons B ()) V3569) (let Result (let V3349 (shen.lazyderef (tl V3336) V3569) (if (= () V3349) (let Hyp (tl V3327) (do (shen.incinfs) (bind V3568 (cons (cons (shen.lazyderef X V3569) (cons : (cons (shen.lazyderef A V3569) ()))) (cons (cons (shen.lazyderef Y V3569) (cons : (cons (shen.lazyderef B V3569) ()))) (shen.lazyderef Hyp V3569))) V3569 V3570))) (if (shen.pvar? V3349) (do (shen.bindv V3349 () V3569) (let Result (let Hyp (tl V3327) (do (shen.incinfs) (bind V3568 (cons (cons (shen.lazyderef X V3569) (cons : (cons (shen.lazyderef A V3569) ()))) (cons (cons (shen.lazyderef Y V3569) (cons : (cons (shen.lazyderef B V3569) ()))) (shen.lazyderef Hyp V3569))) V3569 V3570))) (do (shen.unbindv V3349 V3569) Result))) false))) (do (shen.unbindv V3345 V3569) Result)))) false))) (do (shen.unbindv V3339 V3569) Result))) false))) (if (shen.pvar? V3338) (let B (shen.newpv V3569) (do (shen.bindv V3338 (cons * (cons B ())) V3569) (let Result (let V3350 (shen.lazyderef (tl V3336) V3569) (if (= () V3350) (let Hyp (tl V3327) (do (shen.incinfs) (bind V3568 (cons (cons (shen.lazyderef X V3569) (cons : (cons (shen.lazyderef A V3569) ()))) (cons (cons (shen.lazyderef Y V3569) (cons : (cons (shen.lazyderef B V3569) ()))) (shen.lazyderef Hyp V3569))) V3569 V3570))) (if (shen.pvar? V3350) (do (shen.bindv V3350 () V3569) (let Result (let Hyp (tl V3327) (do (shen.incinfs) (bind V3568 (cons (cons (shen.lazyderef X V3569) (cons : (cons (shen.lazyderef A V3569) ()))) (cons (cons (shen.lazyderef Y V3569) (cons : (cons (shen.lazyderef B V3569) ()))) (shen.lazyderef Hyp V3569))) V3569 V3570))) (do (shen.unbindv V3350 V3569) Result))) false))) (do (shen.unbindv V3338 V3569) Result)))) false)))) (if (shen.pvar? V3337) (let A (shen.newpv V3569) (let B (shen.newpv V3569) (do (shen.bindv V3337 (cons A (cons * (cons B ()))) V3569) (let Result (let V3351 (shen.lazyderef (tl V3336) V3569) (if (= () V3351) (let Hyp (tl V3327) (do (shen.incinfs) (bind V3568 (cons (cons (shen.lazyderef X V3569) (cons : (cons (shen.lazyderef A V3569) ()))) (cons (cons (shen.lazyderef Y V3569) (cons : (cons (shen.lazyderef B V3569) ()))) (shen.lazyderef Hyp V3569))) V3569 V3570))) (if (shen.pvar? V3351) (do (shen.bindv V3351 () V3569) (let Result (let Hyp (tl V3327) (do (shen.incinfs) (bind V3568 (cons (cons (shen.lazyderef X V3569) (cons : (cons (shen.lazyderef A V3569) ()))) (cons (cons (shen.lazyderef Y V3569) (cons : (cons (shen.lazyderef B V3569) ()))) (shen.lazyderef Hyp V3569))) V3569 V3570))) (do (shen.unbindv V3351 V3569) Result))) false))) (do (shen.unbindv V3337 V3569) Result))))) false))) false)) false)) false)) false))) false))) false)) false)) false)) false)) false)) (if (= Case false) (let Case (let V3352 (shen.lazyderef V3567 V3569) (if (cons? V3352) (let V3353 (shen.lazyderef (hd V3352) V3569) (if (cons? V3353) (let V3354 (shen.lazyderef (hd V3353) V3569) (if (cons? V3354) (let V3355 (shen.lazyderef (hd V3354) V3569) (if (= @v V3355) (let V3356 (shen.lazyderef (tl V3354) V3569) (if (cons? V3356) (let X (hd V3356) (let V3357 (shen.lazyderef (tl V3356) V3569) (if (cons? V3357) (let Y (hd V3357) (let V3358 (shen.lazyderef (tl V3357) V3569) (if (= () V3358) (let V3359 (shen.lazyderef (tl V3353) V3569) (if (cons? V3359) (let V3360 (shen.lazyderef (hd V3359) V3569) (if (= : V3360) (let V3361 (shen.lazyderef (tl V3359) V3569) (if (cons? V3361) (let V3362 (shen.lazyderef (hd V3361) V3569) (if (cons? V3362) (let V3363 (shen.lazyderef (hd V3362) V3569) (if (= vector V3363) (let V3364 (shen.lazyderef (tl V3362) V3569) (if (cons? V3364) (let A (hd V3364) (let V3365 (shen.lazyderef (tl V3364) V3569) (if (= () V3365) (let V3366 (shen.lazyderef (tl V3361) V3569) (if (= () V3366) (let Hyp (tl V3352) (do (shen.incinfs) (bind V3568 (cons (cons (shen.lazyderef X V3569) (cons : (cons (shen.lazyderef A V3569) ()))) (cons (cons (shen.lazyderef Y V3569) (cons : (cons (cons vector (cons (shen.lazyderef A V3569) ())) ()))) (shen.lazyderef Hyp V3569))) V3569 V3570))) (if (shen.pvar? V3366) (do (shen.bindv V3366 () V3569) (let Result (let Hyp (tl V3352) (do (shen.incinfs) (bind V3568 (cons (cons (shen.lazyderef X V3569) (cons : (cons (shen.lazyderef A V3569) ()))) (cons (cons (shen.lazyderef Y V3569) (cons : (cons (cons vector (cons (shen.lazyderef A V3569) ())) ()))) (shen.lazyderef Hyp V3569))) V3569 V3570))) (do (shen.unbindv V3366 V3569) Result))) false))) (if (shen.pvar? V3365) (do (shen.bindv V3365 () V3569) (let Result (let V3367 (shen.lazyderef (tl V3361) V3569) (if (= () V3367) (let Hyp (tl V3352) (do (shen.incinfs) (bind V3568 (cons (cons (shen.lazyderef X V3569) (cons : (cons (shen.lazyderef A V3569) ()))) (cons (cons (shen.lazyderef Y V3569) (cons : (cons (cons vector (cons (shen.lazyderef A V3569) ())) ()))) (shen.lazyderef Hyp V3569))) V3569 V3570))) (if (shen.pvar? V3367) (do (shen.bindv V3367 () V3569) (let Result (let Hyp (tl V3352) (do (shen.incinfs) (bind V3568 (cons (cons (shen.lazyderef X V3569) (cons : (cons (shen.lazyderef A V3569) ()))) (cons (cons (shen.lazyderef Y V3569) (cons : (cons (cons vector (cons (shen.lazyderef A V3569) ())) ()))) (shen.lazyderef Hyp V3569))) V3569 V3570))) (do (shen.unbindv V3367 V3569) Result))) false))) (do (shen.unbindv V3365 V3569) Result))) false)))) (if (shen.pvar? V3364) (let A (shen.newpv V3569) (do (shen.bindv V3364 (cons A ()) V3569) (let Result (let V3368 (shen.lazyderef (tl V3361) V3569) (if (= () V3368) (let Hyp (tl V3352) (do (shen.incinfs) (bind V3568 (cons (cons (shen.lazyderef X V3569) (cons : (cons (shen.lazyderef A V3569) ()))) (cons (cons (shen.lazyderef Y V3569) (cons : (cons (cons vector (cons (shen.lazyderef A V3569) ())) ()))) (shen.lazyderef Hyp V3569))) V3569 V3570))) (if (shen.pvar? V3368) (do (shen.bindv V3368 () V3569) (let Result (let Hyp (tl V3352) (do (shen.incinfs) (bind V3568 (cons (cons (shen.lazyderef X V3569) (cons : (cons (shen.lazyderef A V3569) ()))) (cons (cons (shen.lazyderef Y V3569) (cons : (cons (cons vector (cons (shen.lazyderef A V3569) ())) ()))) (shen.lazyderef Hyp V3569))) V3569 V3570))) (do (shen.unbindv V3368 V3569) Result))) false))) (do (shen.unbindv V3364 V3569) Result)))) false))) (if (shen.pvar? V3363) (do (shen.bindv V3363 vector V3569) (let Result (let V3369 (shen.lazyderef (tl V3362) V3569) (if (cons? V3369) (let A (hd V3369) (let V3370 (shen.lazyderef (tl V3369) V3569) (if (= () V3370) (let V3371 (shen.lazyderef (tl V3361) V3569) (if (= () V3371) (let Hyp (tl V3352) (do (shen.incinfs) (bind V3568 (cons (cons (shen.lazyderef X V3569) (cons : (cons (shen.lazyderef A V3569) ()))) (cons (cons (shen.lazyderef Y V3569) (cons : (cons (cons vector (cons (shen.lazyderef A V3569) ())) ()))) (shen.lazyderef Hyp V3569))) V3569 V3570))) (if (shen.pvar? V3371) (do (shen.bindv V3371 () V3569) (let Result (let Hyp (tl V3352) (do (shen.incinfs) (bind V3568 (cons (cons (shen.lazyderef X V3569) (cons : (cons (shen.lazyderef A V3569) ()))) (cons (cons (shen.lazyderef Y V3569) (cons : (cons (cons vector (cons (shen.lazyderef A V3569) ())) ()))) (shen.lazyderef Hyp V3569))) V3569 V3570))) (do (shen.unbindv V3371 V3569) Result))) false))) (if (shen.pvar? V3370) (do (shen.bindv V3370 () V3569) (let Result (let V3372 (shen.lazyderef (tl V3361) V3569) (if (= () V3372) (let Hyp (tl V3352) (do (shen.incinfs) (bind V3568 (cons (cons (shen.lazyderef X V3569) (cons : (cons (shen.lazyderef A V3569) ()))) (cons (cons (shen.lazyderef Y V3569) (cons : (cons (cons vector (cons (shen.lazyderef A V3569) ())) ()))) (shen.lazyderef Hyp V3569))) V3569 V3570))) (if (shen.pvar? V3372) (do (shen.bindv V3372 () V3569) (let Result (let Hyp (tl V3352) (do (shen.incinfs) (bind V3568 (cons (cons (shen.lazyderef X V3569) (cons : (cons (shen.lazyderef A V3569) ()))) (cons (cons (shen.lazyderef Y V3569) (cons : (cons (cons vector (cons (shen.lazyderef A V3569) ())) ()))) (shen.lazyderef Hyp V3569))) V3569 V3570))) (do (shen.unbindv V3372 V3569) Result))) false))) (do (shen.unbindv V3370 V3569) Result))) false)))) (if (shen.pvar? V3369) (let A (shen.newpv V3569) (do (shen.bindv V3369 (cons A ()) V3569) (let Result (let V3373 (shen.lazyderef (tl V3361) V3569) (if (= () V3373) (let Hyp (tl V3352) (do (shen.incinfs) (bind V3568 (cons (cons (shen.lazyderef X V3569) (cons : (cons (shen.lazyderef A V3569) ()))) (cons (cons (shen.lazyderef Y V3569) (cons : (cons (cons vector (cons (shen.lazyderef A V3569) ())) ()))) (shen.lazyderef Hyp V3569))) V3569 V3570))) (if (shen.pvar? V3373) (do (shen.bindv V3373 () V3569) (let Result (let Hyp (tl V3352) (do (shen.incinfs) (bind V3568 (cons (cons (shen.lazyderef X V3569) (cons : (cons (shen.lazyderef A V3569) ()))) (cons (cons (shen.lazyderef Y V3569) (cons : (cons (cons vector (cons (shen.lazyderef A V3569) ())) ()))) (shen.lazyderef Hyp V3569))) V3569 V3570))) (do (shen.unbindv V3373 V3569) Result))) false))) (do (shen.unbindv V3369 V3569) Result)))) false))) (do (shen.unbindv V3363 V3569) Result))) false))) (if (shen.pvar? V3362) (let A (shen.newpv V3569) (do (shen.bindv V3362 (cons vector (cons A ())) V3569) (let Result (let V3374 (shen.lazyderef (tl V3361) V3569) (if (= () V3374) (let Hyp (tl V3352) (do (shen.incinfs) (bind V3568 (cons (cons (shen.lazyderef X V3569) (cons : (cons (shen.lazyderef A V3569) ()))) (cons (cons (shen.lazyderef Y V3569) (cons : (cons (cons vector (cons (shen.lazyderef A V3569) ())) ()))) (shen.lazyderef Hyp V3569))) V3569 V3570))) (if (shen.pvar? V3374) (do (shen.bindv V3374 () V3569) (let Result (let Hyp (tl V3352) (do (shen.incinfs) (bind V3568 (cons (cons (shen.lazyderef X V3569) (cons : (cons (shen.lazyderef A V3569) ()))) (cons (cons (shen.lazyderef Y V3569) (cons : (cons (cons vector (cons (shen.lazyderef A V3569) ())) ()))) (shen.lazyderef Hyp V3569))) V3569 V3570))) (do (shen.unbindv V3374 V3569) Result))) false))) (do (shen.unbindv V3362 V3569) Result)))) false))) false)) false)) false)) false))) false))) false)) false)) false)) false)) false)) (if (= Case false) (let Case (let V3375 (shen.lazyderef V3567 V3569) (if (cons? V3375) (let V3376 (shen.lazyderef (hd V3375) V3569) (if (cons? V3376) (let V3377 (shen.lazyderef (hd V3376) V3569) (if (cons? V3377) (let V3378 (shen.lazyderef (hd V3377) V3569) (if (= @s V3378) (let V3379 (shen.lazyderef (tl V3377) V3569) (if (cons? V3379) (let X (hd V3379) (let V3380 (shen.lazyderef (tl V3379) V3569) (if (cons? V3380) (let Y (hd V3380) (let V3381 (shen.lazyderef (tl V3380) V3569) (if (= () V3381) (let V3382 (shen.lazyderef (tl V3376) V3569) (if (cons? V3382) (let V3383 (shen.lazyderef (hd V3382) V3569) (if (= : V3383) (let V3384 (shen.lazyderef (tl V3382) V3569) (if (cons? V3384) (let V3385 (shen.lazyderef (hd V3384) V3569) (if (= string V3385) (let V3386 (shen.lazyderef (tl V3384) V3569) (if (= () V3386) (let Hyp (tl V3375) (do (shen.incinfs) (bind V3568 (cons (cons (shen.lazyderef X V3569) (cons : (cons string ()))) (cons (cons (shen.lazyderef Y V3569) (cons : (cons string ()))) (shen.lazyderef Hyp V3569))) V3569 V3570))) (if (shen.pvar? V3386) (do (shen.bindv V3386 () V3569) (let Result (let Hyp (tl V3375) (do (shen.incinfs) (bind V3568 (cons (cons (shen.lazyderef X V3569) (cons : (cons string ()))) (cons (cons (shen.lazyderef Y V3569) (cons : (cons string ()))) (shen.lazyderef Hyp V3569))) V3569 V3570))) (do (shen.unbindv V3386 V3569) Result))) false))) (if (shen.pvar? V3385) (do (shen.bindv V3385 string V3569) (let Result (let V3387 (shen.lazyderef (tl V3384) V3569) (if (= () V3387) (let Hyp (tl V3375) (do (shen.incinfs) (bind V3568 (cons (cons (shen.lazyderef X V3569) (cons : (cons string ()))) (cons (cons (shen.lazyderef Y V3569) (cons : (cons string ()))) (shen.lazyderef Hyp V3569))) V3569 V3570))) (if (shen.pvar? V3387) (do (shen.bindv V3387 () V3569) (let Result (let Hyp (tl V3375) (do (shen.incinfs) (bind V3568 (cons (cons (shen.lazyderef X V3569) (cons : (cons string ()))) (cons (cons (shen.lazyderef Y V3569) (cons : (cons string ()))) (shen.lazyderef Hyp V3569))) V3569 V3570))) (do (shen.unbindv V3387 V3569) Result))) false))) (do (shen.unbindv V3385 V3569) Result))) false))) false)) false)) false)) false))) false))) false)) false)) false)) false)) false)) (if (= Case false) (let V3388 (shen.lazyderef V3567 V3569) (if (cons? V3388) (let X (hd V3388) (let Hyp (tl V3388) (let NewHyps (shen.newpv V3569) (do (shen.incinfs) (bind V3568 (cons (shen.lazyderef X V3569) (shen.lazyderef NewHyps V3569)) V3569 (freeze (shen.t*-hyps Hyp NewHyps V3569 V3570))))))) false)) Case)) Case)) Case)) Case)))

(defun shen.show (V3587 V3588 V3589 V3590) (cond ((value shen.*spy*) (do (shen.line) (do (shen.show-p (shen.deref V3587 V3589)) (do (nl 1) (do (nl 1) (do (shen.show-assumptions (shen.deref V3588 V3589) 1) (do (shen.prhush "
> " (stoutput)) (do (shen.pause-for-user) (thaw V3590))))))))) (true (thaw V3590))))

(defun shen.line () (let Infs (inferences) (shen.prhush (cn "____________________________________________________________ " (shen.app Infs (cn " inference" (shen.app (if (= 1 Infs) "" "s") " 
?- " shen.a)) shen.a)) (stoutput))))

(defun shen.show-p (V3592) (cond ((and (cons? V3592) (and (cons? (tl V3592)) (and (= : (hd (tl V3592))) (and (cons? (tl (tl V3592))) (= () (tl (tl (tl V3592)))))))) (shen.prhush (shen.app (hd V3592) (cn " : " (shen.app (hd (tl (tl V3592))) "" shen.r)) shen.r) (stoutput))) (true (shen.prhush (shen.app V3592 "" shen.r) (stoutput)))))

(defun shen.show-assumptions (V3597 V3598) (cond ((= () V3597) shen.skip) ((cons? V3597) (do (shen.prhush (shen.app V3598 ". " shen.a) (stoutput)) (do (shen.show-p (hd V3597)) (do (nl 1) (shen.show-assumptions (tl V3597) (+ V3598 1)))))) (true (shen.f_error shen.show-assumptions))))

(defun shen.pause-for-user () (let Byte (read-byte (stinput)) (if (= Byte 94) (simple-error "input aborted
") (nl 1))))

(defun shen.typedf? (V3600) (cons? (assoc V3600 (value shen.*signedfuncs*))))

(defun shen.sigf (V3602) (concat shen.type-signature-of- V3602))

(defun shen.placeholder () (gensym &&))

(defun shen.base (V3607 V3608 V3609 V3610) (let Case (let V3291 (shen.lazyderef V3608 V3609) (if (= number V3291) (do (shen.incinfs) (fwhen (number? (shen.lazyderef V3607 V3609)) V3609 V3610)) (if (shen.pvar? V3291) (do (shen.bindv V3291 number V3609) (let Result (do (shen.incinfs) (fwhen (number? (shen.lazyderef V3607 V3609)) V3609 V3610)) (do (shen.unbindv V3291 V3609) Result))) false))) (if (= Case false) (let Case (let V3292 (shen.lazyderef V3608 V3609) (if (= boolean V3292) (do (shen.incinfs) (fwhen (boolean? (shen.lazyderef V3607 V3609)) V3609 V3610)) (if (shen.pvar? V3292) (do (shen.bindv V3292 boolean V3609) (let Result (do (shen.incinfs) (fwhen (boolean? (shen.lazyderef V3607 V3609)) V3609 V3610)) (do (shen.unbindv V3292 V3609) Result))) false))) (if (= Case false) (let Case (let V3293 (shen.lazyderef V3608 V3609) (if (= string V3293) (do (shen.incinfs) (fwhen (string? (shen.lazyderef V3607 V3609)) V3609 V3610)) (if (shen.pvar? V3293) (do (shen.bindv V3293 string V3609) (let Result (do (shen.incinfs) (fwhen (string? (shen.lazyderef V3607 V3609)) V3609 V3610)) (do (shen.unbindv V3293 V3609) Result))) false))) (if (= Case false) (let Case (let V3294 (shen.lazyderef V3608 V3609) (if (= symbol V3294) (do (shen.incinfs) (fwhen (symbol? (shen.lazyderef V3607 V3609)) V3609 (freeze (fwhen (not (shen.ue? (shen.lazyderef V3607 V3609))) V3609 V3610)))) (if (shen.pvar? V3294) (do (shen.bindv V3294 symbol V3609) (let Result (do (shen.incinfs) (fwhen (symbol? (shen.lazyderef V3607 V3609)) V3609 (freeze (fwhen (not (shen.ue? (shen.lazyderef V3607 V3609))) V3609 V3610)))) (do (shen.unbindv V3294 V3609) Result))) false))) (if (= Case false) (let V3295 (shen.lazyderef V3607 V3609) (if (= () V3295) (let V3296 (shen.lazyderef V3608 V3609) (if (cons? V3296) (let V3297 (shen.lazyderef (hd V3296) V3609) (if (= list V3297) (let V3298 (shen.lazyderef (tl V3296) V3609) (if (cons? V3298) (let A (hd V3298) (let V3299 (shen.lazyderef (tl V3298) V3609) (if (= () V3299) (do (shen.incinfs) (thaw V3610)) (if (shen.pvar? V3299) (do (shen.bindv V3299 () V3609) (let Result (do (shen.incinfs) (thaw V3610)) (do (shen.unbindv V3299 V3609) Result))) false)))) (if (shen.pvar? V3298) (let A (shen.newpv V3609) (do (shen.bindv V3298 (cons A ()) V3609) (let Result (do (shen.incinfs) (thaw V3610)) (do (shen.unbindv V3298 V3609) Result)))) false))) (if (shen.pvar? V3297) (do (shen.bindv V3297 list V3609) (let Result (let V3300 (shen.lazyderef (tl V3296) V3609) (if (cons? V3300) (let A (hd V3300) (let V3301 (shen.lazyderef (tl V3300) V3609) (if (= () V3301) (do (shen.incinfs) (thaw V3610)) (if (shen.pvar? V3301) (do (shen.bindv V3301 () V3609) (let Result (do (shen.incinfs) (thaw V3610)) (do (shen.unbindv V3301 V3609) Result))) false)))) (if (shen.pvar? V3300) (let A (shen.newpv V3609) (do (shen.bindv V3300 (cons A ()) V3609) (let Result (do (shen.incinfs) (thaw V3610)) (do (shen.unbindv V3300 V3609) Result)))) false))) (do (shen.unbindv V3297 V3609) Result))) false))) (if (shen.pvar? V3296) (let A (shen.newpv V3609) (do (shen.bindv V3296 (cons list (cons A ())) V3609) (let Result (do (shen.incinfs) (thaw V3610)) (do (shen.unbindv V3296 V3609) Result)))) false))) false)) Case)) Case)) Case)) Case)))

(defun shen.by_hypothesis (V3616 V3617 V3618 V3619 V3620) (let Case (let V3282 (shen.lazyderef V3618 V3619) (if (cons? V3282) (let V3283 (shen.lazyderef (hd V3282) V3619) (if (cons? V3283) (let Y (hd V3283) (let V3284 (shen.lazyderef (tl V3283) V3619) (if (cons? V3284) (let V3285 (shen.lazyderef (hd V3284) V3619) (if (= : V3285) (let V3286 (shen.lazyderef (tl V3284) V3619) (if (cons? V3286) (let B (hd V3286) (let V3287 (shen.lazyderef (tl V3286) V3619) (if (= () V3287) (do (shen.incinfs) (identical V3616 Y V3619 (freeze (unify! V3617 B V3619 V3620)))) false))) false)) false)) false))) false)) false)) (if (= Case false) (let V3288 (shen.lazyderef V3618 V3619) (if (cons? V3288) (let Hyp (tl V3288) (do (shen.incinfs) (shen.by_hypothesis V3616 V3617 Hyp V3619 V3620))) false)) Case)))

(defun shen.t*-def (V3626 V3627 V3628 V3629 V3630) (let V3276 (shen.lazyderef V3626 V3629) (if (cons? V3276) (let V3277 (shen.lazyderef (hd V3276) V3629) (if (= define V3277) (let V3278 (shen.lazyderef (tl V3276) V3629) (if (cons? V3278) (let F (hd V3278) (let X (tl V3278) (let Y (shen.newpv V3629) (let E (shen.newpv V3629) (do (shen.incinfs) (shen.t*-defh (compile (lambda Y (shen.<sig+rules> Y)) X (lambda E (if (cons? E) (simple-error (cn "parse error here: " (shen.app E "
" shen.s))) (simple-error "parse error
")))) F V3627 V3628 V3629 V3630)))))) false)) false)) false)))

(defun shen.t*-defh (V3637 V3638 V3639 V3640 V3641 V3642) (let V3272 (shen.lazyderef V3637 V3641) (if (cons? V3272) (let Sig (hd V3272) (let Rules (tl V3272) (do (shen.incinfs) (shen.t*-defhh Sig (shen.ue-sig Sig) V3638 V3639 V3640 Rules V3641 V3642)))) false)))

(defun shen.t*-defhh (V3651 V3652 V3653 V3654 V3655 V3656 V3657 V3658) (do (shen.incinfs) (shen.t*-rules V3656 V3652 1 V3653 (cons (cons V3653 (cons : (cons V3652 ()))) V3655) V3657 (freeze (shen.memo V3653 V3651 V3654 V3657 V3658)))))

(defun shen.memo (V3664 V3665 V3666 V3667 V3668) (let Jnk (shen.newpv V3667) (do (shen.incinfs) (unify! V3666 V3665 V3667 (freeze (bind Jnk (declare (shen.lazyderef V3664 V3667) (shen.lazyderef V3666 V3667)) V3667 V3668))))))

(defun shen.<sig+rules> (V3670) (let Parse_shen.<signature> (shen.<signature> V3670) (if (not (= (fail) Parse_shen.<signature>)) (let Parse_shen.<non-ll-rules> (shen.<non-ll-rules> Parse_shen.<signature>) (if (not (= (fail) Parse_shen.<non-ll-rules>)) (shen.pair (hd Parse_shen.<non-ll-rules>) (cons (shen.hdtl Parse_shen.<signature>) (shen.hdtl Parse_shen.<non-ll-rules>))) (fail))) (fail))))

(defun shen.<non-ll-rules> (V3672) (let YaccParse (let Parse_shen.<rule> (shen.<rule> V3672) (if (not (= (fail) Parse_shen.<rule>)) (let Parse_shen.<non-ll-rules> (shen.<non-ll-rules> Parse_shen.<rule>) (if (not (= (fail) Parse_shen.<non-ll-rules>)) (shen.pair (hd Parse_shen.<non-ll-rules>) (cons (shen.hdtl Parse_shen.<rule>) (shen.hdtl Parse_shen.<non-ll-rules>))) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_shen.<rule> (shen.<rule> V3672) (if (not (= (fail) Parse_shen.<rule>)) (shen.pair (hd Parse_shen.<rule>) (cons (shen.hdtl Parse_shen.<rule>) ())) (fail))) YaccParse)))

(defun shen.ue (V3674) (cond ((and (cons? V3674) (and (cons? (tl V3674)) (and (= () (tl (tl V3674))) (= (hd V3674) protect)))) V3674) ((cons? V3674) (map (lambda Z (shen.ue Z)) V3674)) ((variable? V3674) (concat && V3674)) (true V3674)))

(defun shen.ue-sig (V3676) (cond ((cons? V3676) (map (lambda Z (shen.ue-sig Z)) V3676)) ((variable? V3676) (concat &&& V3676)) (true V3676)))

(defun shen.ues (V3682) (cond ((shen.ue? V3682) (cons V3682 ())) ((cons? V3682) (union (shen.ues (hd V3682)) (shen.ues (tl V3682)))) (true ())))

(defun shen.ue? (V3684) (and (symbol? V3684) (shen.ue-h? (str V3684))))

(defun shen.ue-h? (V3692) (cond ((and (shen.+string? V3692) (and (= "&" (pos V3692 0)) (and (shen.+string? (tlstr V3692)) (= "&" (pos (tlstr V3692) 0))))) true) (true false)))

(defun shen.t*-rules (V3700 V3701 V3702 V3703 V3704 V3705 V3706) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let V3256 (shen.lazyderef V3700 V3705) (if (= () V3256) (do (shen.incinfs) (thaw V3706)) false)) (if (= Case false) (let Case (let V3257 (shen.lazyderef V3700 V3705) (if (cons? V3257) (let Rule (hd V3257) (let Rules (tl V3257) (do (shen.incinfs) (shen.t*-rule (shen.ue Rule) V3701 V3704 V3705 (freeze (cut Throwcontrol V3705 (freeze (shen.t*-rules Rules V3701 (+ V3702 1) V3703 V3704 V3705 V3706)))))))) false)) (if (= Case false) (let Err (shen.newpv V3705) (do (shen.incinfs) (bind Err (simple-error (cn "type error in rule " (shen.app (shen.lazyderef V3702 V3705) (cn " of " (shen.app (shen.lazyderef V3703 V3705) "" shen.a)) shen.a))) V3705 V3706))) Case)) Case)))))

(defun shen.t*-rule (V3712 V3713 V3714 V3715 V3716) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let V3248 (shen.lazyderef V3712 V3715) (if (cons? V3248) (let Patterns (hd V3248) (let V3249 (shen.lazyderef (tl V3248) V3715) (if (cons? V3249) (let Action (hd V3249) (let V3250 (shen.lazyderef (tl V3249) V3715) (if (= () V3250) (let NewHyps (shen.newpv V3715) (do (shen.incinfs) (shen.newhyps (shen.placeholders Patterns) V3714 NewHyps V3715 (freeze (shen.t*-patterns Patterns V3713 NewHyps V3715 (freeze (cut Throwcontrol V3715 (freeze (shen.t*-action (shen.curry (shen.ue Action)) (shen.result-type Patterns V3713) (shen.patthyps Patterns V3713 V3714) V3715 V3716))))))))) false))) false))) false)))))

(defun shen.placeholders (V3722) (cond ((shen.ue? V3722) (cons V3722 ())) ((cons? V3722) (union (shen.placeholders (hd V3722)) (shen.placeholders (tl V3722)))) (true ())))

(defun shen.newhyps (V3728 V3729 V3730 V3731 V3732) (let Case (let V3235 (shen.lazyderef V3728 V3731) (if (= () V3235) (do (shen.incinfs) (unify! V3730 V3729 V3731 V3732)) false)) (if (= Case false) (let V3236 (shen.lazyderef V3728 V3731) (if (cons? V3236) (let V3231 (hd V3236) (let Vs (tl V3236) (let V3237 (shen.lazyderef V3730 V3731) (if (cons? V3237) (let V3238 (shen.lazyderef (hd V3237) V3731) (if (cons? V3238) (let V (hd V3238) (let V3239 (shen.lazyderef (tl V3238) V3731) (if (cons? V3239) (let V3240 (shen.lazyderef (hd V3239) V3731) (if (= : V3240) (let V3241 (shen.lazyderef (tl V3239) V3731) (if (cons? V3241) (let A (hd V3241) (let V3242 (shen.lazyderef (tl V3241) V3731) (if (= () V3242) (let NewHyp (tl V3237) (do (shen.incinfs) (unify! V V3231 V3731 (freeze (shen.newhyps Vs V3729 NewHyp V3731 V3732))))) (if (shen.pvar? V3242) (do (shen.bindv V3242 () V3731) (let Result (let NewHyp (tl V3237) (do (shen.incinfs) (unify! V V3231 V3731 (freeze (shen.newhyps Vs V3729 NewHyp V3731 V3732))))) (do (shen.unbindv V3242 V3731) Result))) false)))) (if (shen.pvar? V3241) (let A (shen.newpv V3731) (do (shen.bindv V3241 (cons A ()) V3731) (let Result (let NewHyp (tl V3237) (do (shen.incinfs) (unify! V V3231 V3731 (freeze (shen.newhyps Vs V3729 NewHyp V3731 V3732))))) (do (shen.unbindv V3241 V3731) Result)))) false))) (if (shen.pvar? V3240) (do (shen.bindv V3240 : V3731) (let Result (let V3243 (shen.lazyderef (tl V3239) V3731) (if (cons? V3243) (let A (hd V3243) (let V3244 (shen.lazyderef (tl V3243) V3731) (if (= () V3244) (let NewHyp (tl V3237) (do (shen.incinfs) (unify! V V3231 V3731 (freeze (shen.newhyps Vs V3729 NewHyp V3731 V3732))))) (if (shen.pvar? V3244) (do (shen.bindv V3244 () V3731) (let Result (let NewHyp (tl V3237) (do (shen.incinfs) (unify! V V3231 V3731 (freeze (shen.newhyps Vs V3729 NewHyp V3731 V3732))))) (do (shen.unbindv V3244 V3731) Result))) false)))) (if (shen.pvar? V3243) (let A (shen.newpv V3731) (do (shen.bindv V3243 (cons A ()) V3731) (let Result (let NewHyp (tl V3237) (do (shen.incinfs) (unify! V V3231 V3731 (freeze (shen.newhyps Vs V3729 NewHyp V3731 V3732))))) (do (shen.unbindv V3243 V3731) Result)))) false))) (do (shen.unbindv V3240 V3731) Result))) false))) (if (shen.pvar? V3239) (let A (shen.newpv V3731) (do (shen.bindv V3239 (cons : (cons A ())) V3731) (let Result (let NewHyp (tl V3237) (do (shen.incinfs) (unify! V V3231 V3731 (freeze (shen.newhyps Vs V3729 NewHyp V3731 V3732))))) (do (shen.unbindv V3239 V3731) Result)))) false)))) (if (shen.pvar? V3238) (let V (shen.newpv V3731) (let A (shen.newpv V3731) (do (shen.bindv V3238 (cons V (cons : (cons A ()))) V3731) (let Result (let NewHyp (tl V3237) (do (shen.incinfs) (unify! V V3231 V3731 (freeze (shen.newhyps Vs V3729 NewHyp V3731 V3732))))) (do (shen.unbindv V3238 V3731) Result))))) false))) (if (shen.pvar? V3237) (let V (shen.newpv V3731) (let A (shen.newpv V3731) (let NewHyp (shen.newpv V3731) (do (shen.bindv V3237 (cons (cons V (cons : (cons A ()))) NewHyp) V3731) (let Result (do (shen.incinfs) (unify! V V3231 V3731 (freeze (shen.newhyps Vs V3729 NewHyp V3731 V3732)))) (do (shen.unbindv V3237 V3731) Result)))))) false))))) false)) Case)))

(defun shen.patthyps (V3738 V3739 V3740) (cond ((= () V3738) V3740) ((and (cons? V3738) (and (cons? V3739) (and (cons? (tl V3739)) (and (= --> (hd (tl V3739))) (and (cons? (tl (tl V3739))) (= () (tl (tl (tl V3739))))))))) (adjoin (cons (hd V3738) (cons : (cons (hd V3739) ()))) (shen.patthyps (tl V3738) (hd (tl (tl V3739))) V3740))) (true (shen.f_error shen.patthyps))))

(defun shen.result-type (V3747 V3748) (cond ((and (= () V3747) (and (cons? V3748) (and (= --> (hd V3748)) (and (cons? (tl V3748)) (= () (tl (tl V3748))))))) (hd (tl V3748))) ((= () V3747) V3748) ((and (cons? V3747) (and (cons? V3748) (and (cons? (tl V3748)) (and (= --> (hd (tl V3748))) (and (cons? (tl (tl V3748))) (= () (tl (tl (tl V3748))))))))) (shen.result-type (tl V3747) (hd (tl (tl V3748))))) (true (shen.f_error shen.result-type))))

(defun shen.t*-patterns (V3754 V3755 V3756 V3757 V3758) (let Case (let V3223 (shen.lazyderef V3754 V3757) (if (= () V3223) (do (shen.incinfs) (thaw V3758)) false)) (if (= Case false) (let V3224 (shen.lazyderef V3754 V3757) (if (cons? V3224) (let Pattern (hd V3224) (let Patterns (tl V3224) (let V3225 (shen.lazyderef V3755 V3757) (if (cons? V3225) (let A (hd V3225) (let V3226 (shen.lazyderef (tl V3225) V3757) (if (cons? V3226) (let V3227 (shen.lazyderef (hd V3226) V3757) (if (= --> V3227) (let V3228 (shen.lazyderef (tl V3226) V3757) (if (cons? V3228) (let B (hd V3228) (let V3229 (shen.lazyderef (tl V3228) V3757) (if (= () V3229) (do (shen.incinfs) (shen.t* (cons Pattern (cons : (cons A ()))) V3756 V3757 (freeze (shen.t*-patterns Patterns B V3756 V3757 V3758)))) false))) false)) false)) false))) false)))) false)) Case)))

(defun shen.t*-action (V3764 V3765 V3766 V3767 V3768) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let V3200 (shen.lazyderef V3764 V3767) (if (cons? V3200) (let V3201 (shen.lazyderef (hd V3200) V3767) (if (= where V3201) (let V3202 (shen.lazyderef (tl V3200) V3767) (if (cons? V3202) (let P (hd V3202) (let V3203 (shen.lazyderef (tl V3202) V3767) (if (cons? V3203) (let Action (hd V3203) (let V3204 (shen.lazyderef (tl V3203) V3767) (if (= () V3204) (do (shen.incinfs) (cut Throwcontrol V3767 (freeze (shen.t* (cons P (cons : (cons boolean ()))) V3766 V3767 (freeze (cut Throwcontrol V3767 (freeze (shen.t*-action Action V3765 (cons (cons P (cons : (cons verified ()))) V3766) V3767 V3768)))))))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V3205 (shen.lazyderef V3764 V3767) (if (cons? V3205) (let V3206 (shen.lazyderef (hd V3205) V3767) (if (= shen.choicepoint! V3206) (let V3207 (shen.lazyderef (tl V3205) V3767) (if (cons? V3207) (let V3208 (shen.lazyderef (hd V3207) V3767) (if (cons? V3208) (let V3209 (shen.lazyderef (hd V3208) V3767) (if (cons? V3209) (let V3210 (shen.lazyderef (hd V3209) V3767) (if (= fail-if V3210) (let V3211 (shen.lazyderef (tl V3209) V3767) (if (cons? V3211) (let F (hd V3211) (let V3212 (shen.lazyderef (tl V3211) V3767) (if (= () V3212) (let V3213 (shen.lazyderef (tl V3208) V3767) (if (cons? V3213) (let Action (hd V3213) (let V3214 (shen.lazyderef (tl V3213) V3767) (if (= () V3214) (let V3215 (shen.lazyderef (tl V3207) V3767) (if (= () V3215) (do (shen.incinfs) (cut Throwcontrol V3767 (freeze (shen.t*-action (cons where (cons (cons not (cons (cons F (cons Action ())) ())) (cons Action ()))) V3765 V3766 V3767 V3768)))) false)) false))) false)) false))) false)) false)) false)) false)) false)) false)) false)) (if (= Case false) (let Case (let V3216 (shen.lazyderef V3764 V3767) (if (cons? V3216) (let V3217 (shen.lazyderef (hd V3216) V3767) (if (= shen.choicepoint! V3217) (let V3218 (shen.lazyderef (tl V3216) V3767) (if (cons? V3218) (let Action (hd V3218) (let V3219 (shen.lazyderef (tl V3218) V3767) (if (= () V3219) (do (shen.incinfs) (cut Throwcontrol V3767 (freeze (shen.t*-action (cons where (cons (cons not (cons (cons (cons = (cons Action ())) (cons (cons fail ()) ())) ())) (cons Action ()))) V3765 V3766 V3767 V3768)))) false))) false)) false)) false)) (if (= Case false) (do (shen.incinfs) (shen.t* (cons V3764 (cons : (cons V3765 ()))) V3766 V3767 V3768)) Case)) Case)) Case)))))

(defun findall (V3774 V3775 V3776 V3777 V3778) (let B (shen.newpv V3777) (let A (shen.newpv V3777) (do (shen.incinfs) (bind A (gensym shen.a) V3777 (freeze (bind B (set (shen.lazyderef A V3777) ()) V3777 (freeze (shen.findallhelp V3774 V3775 V3776 A V3777 V3778)))))))))

(defun shen.findallhelp (V3785 V3786 V3787 V3788 V3789 V3790) (let Case (do (shen.incinfs) (call V3786 V3789 (freeze (shen.remember V3788 V3785 V3789 (freeze (fwhen false V3789 V3790)))))) (if (= Case false) (do (shen.incinfs) (bind V3787 (value (shen.lazyderef V3788 V3789)) V3789 V3790)) Case)))

(defun shen.remember (V3795 V3796 V3797 V3798) (let B (shen.newpv V3797) (do (shen.incinfs) (bind B (set (shen.deref V3795 V3797) (cons (shen.deref V3796 V3797) (value (shen.deref V3795 V3797)))) V3797 V3798))))



